import Dexie, { type EntityTable } from 'dexie';

// Define content part types for multi-modal support
export type ContentPart = TextPart | ImagePart;

export interface TextPart {
    type: 'text';
    text: string;
}

export interface ImagePart {
    type: 'image';
    image: string; // Base64 encoded image data or Data URI
    mimeType?: string; // e.g., "image/jpeg", "image/png"
    alt?: string; // Optional alternative text
}

export interface ChatMessage {
    id?: number; // Auto-incremented primary key by Dexie
    messageId: string; // Original id, will be renamed to avoid conflict
    role: "user" | "assistant";
    content: string | ContentPart[]; // Support for both simple text and multi-modal content
    timestamp: number;
    threadId: string; // Foreign key to ChatThread
}

export interface ChatThread {
    id: string; // Primary key (thread_timestamp_random)
    messages: ChatMessage[]; // This will be populated by querying the messages table
    createdAt: number;
}

// Define the database
class ChatHistoryDB extends Dexie {
    threads!: EntityTable<ChatThread, 'id'>;
    messages!: EntityTable<ChatMessage, 'id'>;

    constructor() {
        super('ChatHistoryDB');
        this.version(1).stores({
            threads: 'id, createdAt', // Primary key 'id', index 'createdAt'
            messages: '++id, messageId, threadId, timestamp' // Primary key 'id', index 'threadId', 'timestamp'
        });
        // messages will be populated on demand or when constructing ChatThread objects
        // So, we don't map ChatThread.messages directly in Dexie schema.
    }
}

const db = new ChatHistoryDB();

export const chatHistory = {
    getThreads: async (): Promise<ChatThread[]> => {
        const threadsFromDB = await db.threads.orderBy('createdAt').toArray();
        
        const threadsWithMessages: ChatThread[] = [];
        for (const thread of threadsFromDB) {
            const messagesForThread = await db.messages.where('threadId').equals(thread.id).sortBy('timestamp');
            threadsWithMessages.push({ ...thread, messages: messagesForThread });
        }
        return threadsWithMessages;
    },

    getThread: async (threadId: string): Promise<ChatThread | null> => {
        const thread = await db.threads.get(threadId);
        if (!thread) {
            return null;
        }
        
        const messagesForThread = await db.messages.where('threadId').equals(threadId).sortBy('timestamp');
        
        return { ...thread, messages: messagesForThread };
    },

    saveMessage: async (threadId: string, message: Omit<ChatMessage, 'threadId' | 'id'>) => {
        let thread = await db.threads.get(threadId);
        if (!thread) {
            // Create new thread if it doesn't exist
            thread = {
                id: threadId,
                messages: [], // Will be populated by queries
                createdAt: Date.now(),
            };
            await db.threads.add(thread);
        }

        const messageToSave: ChatMessage = {
            ...message,
            threadId: threadId,
            // id will be auto-generated by Dexie
        };
        
        await db.messages.add(messageToSave);
    },

    createThread: async (): Promise<string> => {
        const threadId = `thread_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        
        const newThread: ChatThread = {
            id: threadId,
            messages: [], // Messages are stored in their own table
            createdAt: Date.now(),
        };
        
        await db.threads.add(newThread);
        
        return threadId;
    },

    deleteThread: async (threadId: string): Promise<void> => {
        await db.transaction('rw', db.threads, db.messages, async () => {
            // Delete all messages for this thread
            await db.messages.where('threadId').equals(threadId).delete();
            // Delete the thread itself
            await db.threads.delete(threadId);
        });
    },

    clearHistory: async () => {
        await db.transaction('rw', db.threads, db.messages, async () => {
            await db.threads.clear();
            await db.messages.clear();
        });
    },
};